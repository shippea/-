/*
	패키지(package)
- 관련이 있는 타입(객체), 변수, 상수, 커서, 프로시져, 함수, 레코드, 컬렉션, 예외...들의 모임
- 선언부(package), 구현부(pacakge body)로 구성
- 선언부만 있어도 호출해서 사용 가능
- 패키지 선언부에서 선언한 프로시져, 함수는 다른 프로그램에서 호출 가능
	1. 패키지 선언부에서 선언: public item (세션이 종료되지 않는 한 다른 곳에서 사용가능)	
	2. 패키지 바디에서 선언: private item (패키지 내에서만 사용 가능)
	
*/

-- 패키지 선언부
CREATE OR REPLACE PACKAGE PKG_EMP 
IS 
	-- 중첩테이블 타입 선언
	TYPE TYPE_EMP IS TABLE OF VARCHAR2(20);
	NT_EMP TYPE_EMP;
	-- 변수 선언
	V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE;
	-- 상수는 변수type 선언 전에 명시, 초기화 필수
	V_CONST CONSTANT NUMBER := 100;
	-- 커서 선언
	CURSOR CUR_EMP(P_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE)
	IS SELECT * FROM EMPLOYEES e WHERE e.EMPLOYEE_ID = P_EMPID;
	-- 프로시져 선언
	PROCEDURE PROC_PRINTEMPINFO(P_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE);
	-- 함수 선언 (return type까지만 선언)
	FUNCTION FUNC_GETDEPTID(P_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE)
	RETURN NUMBER;
END;

-- 패키지 바디
CREATE OR REPLACE PACKAGE BODY PKG_EMP 
IS 
	-- 선언부에서 선언한 프로시져 구현
	PROCEDURE PROC_PRINTEMPINFO(P_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE)
	IS 
	ROW_EMP EMPLOYEES%ROWTYPE;
	BEGIN
		SELECT * INTO ROW_EMP
		FROM EMPLOYEES e WHERE EMPLOYEE_ID = P_EMPID;
		DBMS_OUTPUT.PUT_LINE (ROW_EMP.DEPARTMENT_ID);
	END; -- PROCEDURE
	
	-- 선언부에서 선언한 함수 구현
	FUNCTION FUNC_GETDEPTID(P_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE)
	RETURN NUMBER
	IS
		V_DEPTID DEPARTMENTS.DEPARTMENT_ID%TYPE;
	BEGIN
		SELECT e.DEPARTMENT_ID 
		INTO V_DEPTID
		FROM EMPLOYEES e
		WHERE e.EMPLOYEE_ID = P_EMPID;
		RETURN V_DEPTID;
	END; -- FUNCTION
END; -- PACKAGE BODY 


DECLARE
	
BEGIN
	-- 생성한 중첩테이블 실행
	PKG_EMP.NT_EMP := PKG_EMP.TYPE_EMP('홍길동','이순신','강감찬');
	DBMS_OUTPUT.PUT_LINE (PKG_EMP.NT_EMP(2));
	-- 생성한 변수 값 설정
	PKG_EMP.V_EMPID := 3000;
	DBMS_OUTPUT.PUT_LINE (PKG_EMP.V_EMPID);
	-- 생성한 상수 출력
	DBMS_OUTPUT.PUT_LINE (PKG_EMP.V_CONST);
	-- 생성한 커서 실행
	FOR REC_EACHROW IN PKG_EMP.CUR_EMP(150)
	LOOP
		DBMS_OUTPUT.PUT_LINE(REC_EACHROW.FIRST_NAME);
	END LOOP;
	-- 생선한 프로시져 실행
	PKG_EMP.PROC_PRINTEMPINFO(120);
	-- 생성한 함수 실행
	DBMS_OUTPUT.PUT_LINE(PKG_EMP.FUNC_GETDEPTID(160));
END;


/*
	패키지 스코프
-- 1. 패키지 선언부에서 선언한 것들은 세션스코프 (세션 로그아웃 전까지 값을 유지) -> PUBLIC ITEM
-- 2. 패키지 바디에서 선언한 것들은 패키지스코프 (패키지 내에서만 값을 유지) -> PRIVATE ITEM
-- 3. 외부에서 PRIVATE ITEM에 접근하려면 PUBLIC GETEER/SETTER를 제공해야 함

*/

CREATE OR REPLACE PACKAGE PKG_SCOPE
IS
	-- 패키지 선언부에서 선언한 세션스코프는 외부에서 사용 가능
	V_PKG_VAR VARCHAR2(50);
	V_PKG_CONST CONSTANT VARCHAR2(50) := '패키지 선언 상수';
	FUNCTION GET_V_PKG_BODY_VAR RETURN VARCHAR2;
	PROCEDURE SET_V_PKG_BODY_VAR(P_PKG_BODY_VAR VARCHAR2);
END;

CREATE OR REPLACE PACKAGE BODY PKG_SCOPE
IS
	-- 패키지 바디에서 선언한 패키지스코프는 get/set을 통해 외부에서 사용가능
	V_PKG_BODY_VAR VARCHAR2(50);
	V_PKG_BODY_CONST CONSTANT VARCHAR2(50) := '패키지 바디 선언 상수';
	-- get
	FUNCTION GET_V_PKG_BODY_VAR RETURN VARCHAR2
	IS
	BEGIN
	RETURN V_PKG_BODY_VAR;
	END;
	-- set
	PROCEDURE SET_V_PKG_BODY_VAR(P_PKG_BODY_VAR VARCHAR2)
	IS
	BEGIN
	V_PKG_BODY_VAR := P_PKG_BODY_VAR;
	END;
END;

BEGIN
-- 선언부에서 선언한 변수들이라 외부에서 불러올 수 있음
PKG_SCOPE.V_PKG_VAR := '패키지 선언 변수';
DBMS_OUTPUT.PUT_LINE(PKG_SCOPE.V_PKG_VAR);
DBMS_OUTPUT.PUT_LINE(PKG_SCOPE.V_PKG_CONST);

-- body에서 선언한 변수들이라 외부에서 불러오려하면 선언하지 않은 변수라는 error 발생
PKG_SCOPE.V_PKG_BODY_VAR := '패키지 바디 선언 변수';
DBMS_OUTPUT.PUT_LINE(PKG_SCOPE.V_PKG_BODY_VAR);
DBMS_OUTPUT.PUT_LINE(PKG_SCOPE.V_PKG_BODY_CONST);

-- body에서 선언한 변수들은 get/set으로 변수 값을 설정하고 값을 불러옴
-- set에 값 설정
PKG_SCOPE.SET_V_PKG_BODY_VAR('패키지 바디 선언 변수');
-- get으로 값 불러옴
DBMS_OUTPUT.PUT_LINE(PKG_SCOPE.GET_V_PKG_BODY_VAR());
END;


-- 패키지에 커서, 레코드, 컬렉션 사용
CREATE OR REPLACE PACKAGE PKG_DEPTJOBS 
IS
	-- 세션에서 패키지 데이터 공유를 방지하고 호출마다 초기화해주는 선언
	PRAGMA SERIALLY_REUSABLE;
	-- 선언부에서 커서 생성
	CURSOR CUR_DEPT IS SELECT * FROM DEPARTMENTS;
	-- 선언부에서 커서 선언만 -> body에서 생성
	CURSOR CUR_JOBS RETURN JOBS%ROWTYPE;
	-- 선언부에서 변수 선언
	ROW_JOB JOBS%ROWTYPE;
	-- 선언부에서 중첩테이블 선언
	TYPE TYPE_DEPT IS TABLE OF VARCHAR2(30);
	V_DEPT TYPE_DEPT;
END;

CREATE OR REPLACE PACKAGE BODY PKG_DEPTJOBS 
IS
	PRAGMA SERIALLY_REUSABLE;
	-- 선언부에서 선언만 한 커서 생성
	CURSOR CUR_JOBS RETURN JOBS%ROWTYPE
	IS
	SELECT * FROM JOBS;
END;

-- 실행
BEGIN
	-- 선언부에서 생성한 커서 실행
	FOR EACHROW IN PKG_DEPTJOBS.CUR_DEPT
	LOOP
		DBMS_OUTPUT.PUT_LINE(EACHROW.DEPARTMENT_ID);
	END LOOP;

	DBMS_OUTPUT.PUT_LINE('---------------');

	-- 선언부에서 선언만 하고 body에서 생성한 커서 실행
	OPEN PKG_DEPTJOBS.CUR_JOBS;
	LOOP
		FETCH PKG_DEPTJOBS.CUR_JOBS INTO PKG_DEPTJOBS.ROW_JOB;
		EXIT WHEN PKG_DEPTJOBS.CUR_JOBS%NOTFOUND;
		DBMS_OUTPUT.PUT_LINE(PKG_DEPTJOBS.ROW_JOB.JOB_ID);
	END LOOP;
	-- 패키지에서 선언한 커서는 반드시 닫아야 메모리 누수를 방지할 수 있음
	CLOSE PKG_DEPTJOBS.CUR_JOBS;

	DBMS_OUTPUT.PUT_LINE('---------------');

	-- 선언부에서 선언한 중첩테이블 실행
	PKG_DEPTJOBS.V_DEPT := PKG_DEPTJOBS.TYPE_DEPT();
	PKG_DEPTJOBS.V_DEPT.EXTEND;
	PKG_DEPTJOBS.V_DEPT(1) := 'HELLO';
	PKG_DEPTJOBS.V_DEPT.EXTEND;
	PKG_DEPTJOBS.V_DEPT(2) := 'KITTY';
	DBMS_OUTPUT.PUT_LINE(PKG_DEPTJOBS.V_DEPT(1)||' '||PKG_DEPTJOBS.V_DEPT(2));
END; -- pakcage


/*
	오라클 객체 정보 조회

*/

SELECT * FROM ALL_OBJECTS
-- OBJECT_TYPE에 object, procedure, pacakge 등.. 검색할 것을 입력
-- OWNER은 shippear, hr... 계정명 입력
WHERE OBJECT_TYPE='PROCEDURE' AND OWNER='HR';

SELECT * FROM ALL_OBJECTS
WHERE OBJECT_TYPE='PACAKGE' AND OWNER='HR';

SELECT * FROM ALL_OBJECTS
WHERE OBJECT_TYPE='TABLE' AND OWNER='HR';

-- 객체 DDL 구문 확인
SELECT DBMS_METADATA.GET_DDL('TABLE','EMPLOYEES','HR') FROM dual;

SELECT DBMS_METADATA.GET_DDL('PACKAGE','PKG_EMP','HR') FROM dual;

-- RANDOM 문자열
-- ''는 주어진 약속값
SELECT 
	DBMS_RANDOM.STRING('U',20) AS 대문자,
	DBMS_RANDOM.STRING('L',20) AS 소문자,
	DBMS_RANDOM.STRING('A',20) AS 대소문자,
	DBMS_RANDOM.STRING('X',20) AS 대문자숫자,
	DBMS_RANDOM.STRING('P',20) AS 혼합
FROM dual;


/*
	DBMS_JOB
- 오라클에서 주기적으로 어떤 작업을 수행하고 싶을 때 사용
- 로그, 백업 등에 활용되고 있음
- 단점: 주기설정이 세밀하지 못함
	   SQL, PL/SQL만 주기적으로 실행가능
*/

CREATE TABLE TBL_LOG (
	LOGSEQ NUMBER PRIMARY KEY,
	LOGCONTENT VARCHAR2(4000),
	LOGDATE DATE
);

-- seq생생 -> 1부터 1씩 증가할 수 있음
CREATE SEQUENCE SEQ_LOG;

CREATE OR REPLACE PROCEDURE PROC_JOB
IS
BEGIN 
	INSERT INTO TBL_LOG VALUES (SEQ_LOG.NEXTVAL, 'LOG'||SYSDATE,SYSDATE);
	COMMIT;
END;

-- 잡 등록
DECLARE 
	-- 오라클이 부여하는 잡번호를 저장할 변수
	V_JOB_NO NUMBER;
BEGIN
	DBMS_JOB.SUBMIT(
		-- 오라클이 부여하는 잡 번호
		JOB => V_JOB_NO,
		-- what: 수생할 잡 (; 까먹지말기)
		WHAT => 'PROC_JOB;',
		-- 수행 시작시간
		NEXT_DATE => SYSDATE,
		-- 수행 간격
		INTERVAL => 'SYSDATE + 5/60/60/24'
	);
	COMMIT;
END;

SELECT *
FROM TBL_LOG
ORDER BY LOGSEQ DESC;

-- 잡 정보를 조회 -> 안쓰는 잡을 확인할 수 있음
SELECT * FROM USER_JOBS;

-- 잡 중지
BEGIN
	DBMS_JOB.BROKEN(1,TRUE);
	COMMIT;
END;

-- 잡 재가동
BEGIN
	DBMS_JOB.BROKEN(1,FALSE);
	COMMIT;
END;

-- 잡 속성 변경
BEGIN
	DBMS_JOB.CHANGE(
		JOB => 1,
		WHAT => 'PROC_JOB;',
		NEXT_DATE => SYSDATE,
		INTERVAL => 'SYSDATE + 10/60/60/24'
	);
	COMMIT;
END;

-- 잡 삭제
-- 안 쓰는 잡은 무조건 삭제해주기!
BEGIN 
	DBMS_JOB.REMOVE(1);
	COMMIT;
END;

/*
	DBMS_SCHEDULER
- 오라클의 주기적인 작업을 위해 존재하는 패키지
- DBMS_JOB의 상위 버전 (더 많은 기능을 제공)
- SQL, PL/SQL, 외부 프로그램 수행도 가능
- 시간기반, 이벤트기반 (job은 시간기반)
- 체인(프로그램 체인): job 내에서 순차적으로 수행되는 일련의 프로그램
- 프로그램, 스케쥴, 잡, 체인, 체인룰로 모듈화 되어서 구성됨

*/

BEGIN
	DBMS_SCHEDULER.CREATE_PROGRAM(
		PROGRAM_NAME => 'ORA_SCH_PROG',
		PROGRAM_TYPE => 'STORED_PROCEDURE',
		PROGRAM_ACTION => 'PROC_JOB',
		COMMENTS => '오라클 스케쥴러 - 스케쥴러 (프로시져 사용)'
	);
END;

-- 프로그램 조회
SELECT * FROM USER_SCHEDULER_PROGRAMS;

-- 잡 생성
BEGIN
	DBMS_SCHEDULER.CREATE_JOB(
		JOB_NAME => 'ORA_SCH_JOB',
		JOB_TYPE => 'STORED_PROCEDURE',
		JOB_ACTION => 'PROC_JOB',
		REPEAT_INTERVAL => 'FREQ=SECONDLY; INTERVAL=5',
		COMMENTS => '오라클 스케쥴러 - 잡'
	);
END;

-- 잡 조회
SELECT * FROM USER_SCHEDULER_JOBS;

-- 잡 활성화
BEGIN
	DBMS_SCHEDULER.ENABLE('ORA_SCH_JOB');
END;

SELECT *
FROM TBL_LOG
ORDER BY LOGSEQ DESC;

-- 잡 생성
BEGIN
	DBMS_SCHEDULER.CREATE_JOB(
		JOB_NAME => 'ORA_SCH_JOB2',
		JOB_TYPE => 'EXECUTABLE',
		JOB_ACTION => 'C:/BAT/SCH.BAT',
		REPEAT_INTERVAL => 'FREQ=SECONDLY; INTERVAL=5',
		COMMENTS => '오라클 스케줄러 - 외부파일(OS의 실행파일) 실행'
	);
END;

-- 잡 enable 설정
BEGIN
	DBMS_SCHEDULER.ENABLE('ORA_SCH_JOB2');
END;

-- 잡이 계속 작동하는지 run_count로 확인
SELECT RUN_COUNT FROM USER_SCHEDULER_JOBS;

-- 잡 삭제
BEGIN
	DBMS_SCHEDULER.DROP_JOB('ORA_SCH_JOB');
	DBMS_SCHEDULER.DROP_JOB('ORA_SCH_JOB2');
END;

/* eclipse와 oracle 연동하여 함수, 프로시져 불러와보기 */

-- CallableTest1 (CallableStatement용 프로시져)
CREATE OR REPLACE PROCEDURE PROC_CALL(
	P_EMPID IN EMPLOYEES.EMPLOYEE_ID%TYPE,
	P_DEPTID OUT EMPLOYEES.DEPARTMENT_ID%TYPE
) 
IS
BEGIN
	SELECT e.DEPARTMENT_ID
	INTO P_DEPTID
	FROM EMPLOYEES e
	WHERE e.EMPLOYEE_ID = P_EMPID;
END;

-- CallableTest2 (CallableStatemnet용 함수) 
CREATE OR REPLACE FUNCTION FUNC_CALL(
	NUM1 NUMBER, NUM2 NUMBER
)
RETURN NUMBER 
IS 
BEGIN 
	RETURN NUM1 + NUM2;
END;


BEGIN
	DBMS_OUTPUT.PUT_LINE(FUNC_CALL(3,5));
END;

-- CallableTest3 (실습)
CREATE OR REPLACE FUNCTION FUNC_EMP_CNT(
	F_DEPT_ID EMPLOYEES.DEPARTMENT_ID%TYPE
)
RETURN NUMBER
IS 
	F_EMP_CNT NUMBER;
BEGIN
	SELECT count(*)
	INTO F_EMP_CNT
	FROM EMPLOYEES e
	WHERE e.DEPARTMENT_ID = F_DEPT_ID;
	RETURN F_EMP_CNT;
END;

BEGIN
	DBMS_OUTPUT.PUT_LINE(FUNC_EMP_CNT(90));
END;

-- CallableTest4 (CallableStatement용 커서를 사용하는 프로시져)
CREATE OR REPLACE PROCEDURE PROC_CALL_CUR(
	P_EMPID IN EMPLOYEES.DEPARTMENT_ID%TYPE,
	CUR_EMP OUT SYS_REFCURSOR
)
IS
BEGIN
	OPEN CUR_EMP FOR 
	SELECT e.EMPLOYEE_ID, e.FIRST_NAME, e.LAST_NAME
	FROM EMPLOYEES e
	WHERE e.DEPARTMENT_ID = P_EMPID;
END;


DECLARE 
	eid EMPLOYEES.EMPLOYEE_ID%TYPE;
	efn EMPLOYEES.FIRST%TYPE;
	eln EMPLOYEES.EMPLOYEE_ID%TYPE;
BEGIN
	
END

