/*
커서선언: CURSOR 커서변수명 (매개변수리스트) -> declare 선언부에서 입력
close ~ close는 begin~end 실행부에서 입력
오픈: OPEN 커서변수명 (인자리스트)
패치: FETCH 커서변수명 INTO (변수리스트 또는 %ROWTYPE)
									-> 하나의 행 전체 TYPE
   									예) SELECT * FROM DEPARTMENT d
 	-> into 안의 변수에게 커서의 매개변수를 값을 던져줌
클로즈: CLOSE 커서변수명
*/

DECLARE
	V_FIRSTNAME EMPLOYEES.FIRST_NAME%TYPE;
	-- 커서변수명 (매개변수리스트)
	CURSOR CUR_EMP(P_DEPTID EMPLOYEES.DEPARTMENT_ID%TYPE)
	IS
	SELECT FIRST_NAME||' '||LAST_NAME
	FROM EMPLOYEES
	-- 커서의 매개변수리스트와 일치하는지 체크
	WHERE DEPARTMENT_ID = P_DEPTID;
BEGIN
	-- 커서의 open ~ close는 실행부 안에서 수행 
	OPEN CUR_EMP (90);
	LOOP 
		-- v_firstname에 cur_emp 커서의 값들을 던져줌
		FETCH CUR_EMP INTO V_FIRSTNAME;
		-- 더 이상 fetch할 게 존재하지 않으면 fetch 종료
	    EXIT WHEN CUR_EMP%NOTFOUND;
	   	DBMS_OUTPUT.PUT_LINE(V_FIRSTNAME);
	END LOOP;
	CLOSE CUR_EMP;	
END;


/*
for과 함께 cursor 사용
open ~ close 필요 x 
문법: FOR 레코드변수명 IN 커서변수명
*/ 

DECLARE 
	CURSOR CUR_EMP (P_DEPTID EMPLOYEES.DEPARTMENT_ID%TYPE)
	IS 
	SELECT EMPLOYEE_ID
	FROM EMPLOYEES
	WHERE DEPARTMENT_ID = P_DEPTID;
BEGIN
	-- EMP_REC record에 CUR_EMP 커서의 값들을 넣어줌
	FOR EMP_REC IN CUR_EMP(90)
	LOOP
		-- 변수명 = record명.column명
		DBMS_OUTPUT.PUT_LINE(EMP_REC.EMPLOYEE_ID);
	END LOOP;
END;


/*
익명커서
문법: FOR 레코드변수명 IN (select절)
*/

BEGIN
	FOR EMP_REC IN (SELECT EMPLOYEE_ID
					FROM EMPLOYEES
					WHERE DEPARTMENT_ID = 90)
	LOOP
		DBMS_OUTPUT.PUT_LINE(EMP_REC.EMPLOYEE_ID);
	END LOOP;
END;

/* 
커서변수: 커서를 변수로 사용
	1. 강한타입: RETURN 구문이 있는 커서변수 -> 커서가 가리키는 결과를 RETUNR에서 선언한 type으로 제한함
	2. 약한타입: RETURN 구문이 없는 커서변수 -> 커서가 가리키는 결과의 type에 제한x
	
맨 위에 설명된 cursor is 안에 select문을 넣어 선언한 cursor는 상수cursor
*/

DECLARE
	-- rowtype: 한 행 전체에 대한 type을 받아옴
	-- 예) select * from employee의 모든 것을 받아올 수 있음
	V_EMPROW EMPLOYEES%ROWTYPE;
	TYPE TYPE_CUR_EMP IS REF CURSOR
	-- 강한타입: RETURN 구문에서 선언한 type으로만 cursor가 값을 받을 수 있음
	RETURN EMPLOYEES%ROWTYPE;
	-- TYPE_CUR_EMP type의 커서변수 생성
	CUR_EMP TYPE_CUR_EMP;
BEGIN
	OPEN CUR_EMP FOR
	SELECT * FROM EMPLOYEES;
	LOOP
		FETCH CUR_EMP INTO V_EMPROW;
		DBMS_OUTPUT.PUT_LINE (V_EMPROW.EMPLOYEE_ID);
		EXIT WHEN CUR_EMP%NOTFOUND;
	END LOOP;
	CLOSE CUR_EMP;
END;

/*
SYS_REFCURSOR: 오라클 시스템 자체에서 이미 만들어져 있는 REF CURSOR (커서변수)
*/

DECLARE
	V_EMPROW EMPLOYEES%ROWTYPE;
	-- sys_refcursor은 약한타입의 커서변수type
	CUR_EMP SYS_REFCURSOR;
BEGIN
	OPEN CUR_EMP FOR
	SELECT * FROM EMPLOYEES;
	LOOP 
		FETCH CUR_EMP INTO V_EMPROW;
		DBMS_OUTPUT.PUT_LINE(V_EMPROW.EMAIL);
		EXIT WHEN CUR_EMP%NOTFOUND;
	END LOOP;
	CLOSE CUR_EMP;
END;


/* 커서를 매개변수로 사용 */
CREATE OR REPLACE PROCEDURE PROC_CURPARAM
	-- 프로시져에 inout 변수로 cursor를 받음
	(P_REFCURSOR IN OUT SYS_REFCURSOR)
IS
BEGIN 
	OPEN P_REFCURSOR FOR 
	SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = 90;
END;

DECLARE
	V_EMPID EMPLOYEES.EMPLOYEE_ID%TYPE;
	CUR_EMP SYS_REFCURSOR;
BEGIN
	PROC_CURPARAM(CUR_EMP);
	LOOP
		FETCH CUR_EMP INTO V_EMPID;
		EXIT WHEN CUR_EMP%NOTFOUND;
		DBMS_OUTPUT.PUT_LINE(V_EMPID);
	END LOOP;
	CLOSE CUR_EMP;
END;


/* 커서 표현식: select구문 내에 커서를 사용 */
DECLARE 
	CURSOR CUR_MAIN
	IS
	-- select에 subquery를 사용하면 두개의 행 이상의 결과일 때 오류가 나는데 cursor을 사용하면 오류 해결할 수 있음
	SELECT d.DEPARTMENT_NAME,
		CURSOR(SELECT e.FIRST_NAME||' '||e.LAST_NAME FROM EMPLOYEES e WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID)
	FROM DEPARTMENTS d
	WHERE d.DEPARTMENT_ID = 90;
	V_DEPTNAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;
	CUR_SUB SYS_REFCURSOR;
	V_EMPNAME varchar2(50);
BEGIN
	OPEN CUR_MAIN;
	LOOP 
		FETCH CUR_MAIN INTO V_DEPTNAME, CUR_SUB;
		EXIT WHEN CUR_MAIN%NOTFOUND;
		LOOP 
			FETCH CUR_SUB INTO V_EMPNAME;
			EXIT WHEN CUR_SUB%NOTFOUND;
			DBMS_OUTPUT.PUT_LINE(V_DEPTNAME||' '||V_EMPNAME);
		END LOOP;
		CLOSE CUR_SUB;
	END LOOP;
	CLOSE CUR_MAIN;
END;


/* 
 	 # 실습0
	커서를 활용해서 부서 아이디를 입력하면 부서내
	직원 명단(직원아이디, 직원풀네임), 직원의 수를 리턴하는 프로시져 생성하고 출력
	프로시져명: PROC_EMPINFO, 커서명: CUR_EMP 
*/

-- 내 답
CREATE OR REPLACE PROCEDURE PROC_EMPINFO
	(P_REFCURSOR IN OUT SYS_REFCURSOR, P_DEPTID IN EMPLOYEES.DEPARTMENT_ID%TYPE)
IS
BEGIN
	OPEN P_REFCURSOR FOR 
	SELECT e1.EMPLOYEE_ID, e1.FIRST_NAME||' '||e1.LAST_NAME, 
		CURSOR(SELECT * FROM EMPLOYEES e2 WHERE e2.DEPARTMENT_ID = e1.DEPARTMENT_ID)
	FROM EMPLOYEES e1
	WHERE e1.DEPARTMENT_ID = P_DEPTID;
END;

DECLARE
	V_EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
	V_EMP_NAME varchar2(50);
	V_EMPROW EMPLOYEES%ROWTYPE;
	CUR_EMP SYS_REFCURSOR;
	CUR_SUB1 SYS_REFCURSOR;
BEGIN
	PROC_EMPINFO(CUR_EMP,100);
	LOOP
		FETCH CUR_EMP INTO V_EMP_ID, V_EMP_NAME, CUR_SUB1;
		EXIT WHEN CUR_EMP%NOTFOUND;
			LOOP 
				FETCH CUR_SUB1 INTO V_EMPROW;
				EXIT WHEN CUR_SUB1%NOTFOUND;
			END LOOP;
		DBMS_OUTPUT.PUT_LINE(CUR_SUB1%ROWCOUNT);			
	END LOOP;
	CLOSE CUR_EMP;
END;

-- 다른 풀이

CREATE OR REPLACE PROCEDURE PROC_EMPINFO2(
	P_MAIN_CUR IN OUT SYS_REFCURSOR,
	P_DEPT_ID IN EMPLOYEES.DEPARTMENT_ID%TYPE)
IS 
BEGIN
	OPEN P_MAIN_CUR FOR
	SELECT e1.EMPLOYEE_ID, e1.FIRST_NAME||' '||e1.LAST_NAME,
		-- select할떄 1개의 행씩 읽어오는데 column에 결과값이 여러 행인인 select를 넣으면 값을 다 불러올수가 없어 오류가 발생
		--									-> cursor로 받아주면 여러 값을 1개의 집합으로 인식시켜 1개의 행에 다 불러올 수 있게 해줌
		CURSOR (SELECT count(e2.EMPLOYEE_ID) cnt FROM EMPLOYEES e2 WHERE e2.DEPARTMENT_ID = e1.DEPARTMENT_ID)
	FROM EMPLOYEES e1
	WHERE e1.DEPARTMENT_ID = P_DEPT_ID;
END;



DECLARE
	V_EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE;
	V_EMP_NAME VARCHAR2(100);
	V_EMP_CNT NUMBER;
	V_MAIN_CUR SYS_REFCURSOR;
	V_SUB_CUR SYS_REFCURSOR;
BEGIN
	PROC_EMPINFO2(V_MAIN_CUR,100);
	LOOP
		FETCH V_MAIN_CUR INTO V_EMP_ID, V_EMP_NAME, V_SUB_CUR;
		EXIT WHEN V_MAIN_CUR%NOTFOUND; 
			LOOP
				FETCH V_SUB_CUR INTO V_EMP_CNT;
				EXIT WHEN	V_SUB_CUR%NOTFOUND;
			END LOOP;
			DBMS_OUTPUT.PUT_LINE(V_EMP_ID||' '||V_EMP_NAME||' '||V_EMP_CNT);
	END LOOP;
	CLOSE V_MAIN_CUR;
END;


/* 
 	 # 실습1
	월급이 전체 직원의 월급 평균보다 적은 직원의 수를 출력 
*/

DECLARE
	cnt NUMBER;
	CURSOR cur_main
	IS
	SELECT count(e1.EMPLOYEE_ID)
	FROM EMPLOYEES e1
	WHERE e1.SALARY <(SELECT avg(nvl(e2.SALARY,0)) FROM EMPLOYEES e2);
BEGIN
	OPEN cur_main;
	LOOP
		FETCH cur_main INTO cnt;
		EXIT WHEN cur_main%NOTFOUND;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE('인원수: '||cnt);
	CLOSE cur_main;
END;

/*
	 # 실습2
	REGION_NAME을 입력하면 소속국가들의 데이터를 출력하는 프로시져를 생성하고 출력
*/
CREATE OR REPLACE PROCEDURE PROC_CO_DATA (
	P_REG_NAME IN REGIONS.REGION_NAME%TYPE,
	P_CUR_MAIN IN OUT SYS_REFCURSOR)
IS
BEGIN
	OPEN P_CUR_MAIN FOR 
	SELECT c.*
	FROM COUNTRIES c, REGIONS r
	WHERE c.REGION_ID = r.REGION_ID 
		AND r.REGION_NAME = P_REG_NAME;
END;

DECLARE
	REG_NAME REGIONS.REGION_NAME%TYPE;
	CO_DATA COUNTRIES%ROWTYPE;
	CUR_MAIN SYS_REFCURSOR;
BEGIN
	PROC_CO_DATA('Asia',CUR_MAIN);
	LOOP
		FETCH CUR_MAIN INTO CO_DATA;
		EXIT WHEN CUR_MAIN%NOTFOUND;
	END LOOP;
	DBMS_OUTPUT.PUT_LINE(CO_DATA.REGION_ID);
	CLOSE CUR_MAIN;
END;


/*
	 # 실습3
	JOB_ID를 입력하면 해당 직무를 수행하는 직원들의 평균월급과
	본인월급의 차를 출력
	직원아이디, 직원풀네임, 월급, 평균월급, 월급차
*/

-- function
CREATE OR REPLACE FUNCTION FUNC_AVGSAL(
	F_JOB_ID EMPlOYEES.JOB_ID%TYPE
)
RETURN NUMBER 
IS
	V_AVGSAL NUMBER;
BEGIN 
	SELECT avg(nvl(e.SALARY,0))
	INTO V_AVGSAL
	FROM EMPLOYEES e
	WHERE e.JOB_ID = F_JOB_ID;
	RETURN V_AVGSAL;
END;

-- procedure
CREATE OR REPLACE PROCEDURE PROG_AVGSAL(
	P_J_ID IN EMPLOYEES.JOB_ID%TYPE,
	P_AVG_SALARY OUT NUMBER)
IS 
BEGIN 
	SELECT avg(nvl(e.SALARY,0))
	INTO P_AVG_SALARY
	FROM EMPLOYEES e
	WHERE e.JOB_ID = P_J_ID;
END;

-- 실행
DECLARE 
	AVG_SALARY NUMBER;
	ROW_EMP EMPLOYEES%ROWTYPE;
	CUR_MAIN SYS_REFCURSOR;
BEGIN
	AVG_SALARY := FUNC_AVGSAL('IT_PROG');
--	PROG_AVGSAL('IT_PROG',AVG_SALARY);
	OPEN CUR_MAIN FOR
		SELECT * INTO ROW_EMP
		FROM EMPLOYEES e
		WHERE e.JOB_ID = 'IT_PROG';
	LOOP
		FETCH CUR_MAIN INTO ROW_EMP;
		EXIT WHEN CUR_MAIN%NOTFOUND;
		DBMS_OUTPUT.PUT_LINE(ROW_EMP.EMPLOYEE_ID||' '||
							ROW_EMP.FIRST_NAME||' '||
							ROW_EMP.LAST_NAME||' '||
							ROW_EMP.SALARY||' '||AVG_SALARY||' '||
							(AVG_SALARY-ROW_EMP.SALARY)
							);
	END LOOP;
	CLOSE CUR_MAIN;
END;

-- cur_sub 추가해보기

SELECT avg(nvl(e1.SALARY,0)), CURSOR (SELECT e2.EMPLOYEE_ID FROM EMPLOYEES e2 WHERE e2.JOB_ID = e1.JOB_ID)
FROM EMPLOYEES e1
WHERE e1.JOB_ID = 'IT_PROG'
GROUP BY e1.JOB_ID;

-- 연습

SELECT avg_sal_t.avg_sal,
	CURSOR (SELECT e2.EMPLOYEE_ID, e2.FIRST_NAME||' '||e2.LAST_NAME, e2.SALARY, avg_sal_t.avg_sal-e2.SALARY 
			FROM EMPLOYEES e2 
			WHERE e2.JOB_ID = avg_sal_t.jid
			GROUP BY e2.EMPLOYEE_ID, e2.FIRST_NAME||' '||e2.LAST_NAME, e2.SALARY)
FROM (SELECT avg(nvl(e1.SALARY,0)) avg_sal, e1.JOB_ID jid  FROM EMPLOYEES e1 WHERE e1.JOB_ID = 'IT_PROG' GROUP BY e1.JOB_ID) avg_sal_t;


SELECT e.EMPLOYEE_ID, e.FIRST_NAME||' '||e.LAST_NAME, e.SALARY, avg(nvl(e.SALARY,0)), e.salary-job_t.avg_sal
FROM EMPLOYEES e, 
	(SELECT avg(e2.SALARY) avg_sal, e2.JOB_ID jid FROM EMPLOYEES e2 WHERE e2.JOB_ID ='IT_PROG' GROUP BY e2.JOB_ID) job_t
WHERE e.JOB_ID = job_t.jid
GROUP BY e.EMPLOYEE_ID, e.FIRST_NAME||' '||e.LAST_NAME, e.SALARY, e.salary-job_t.avg_sal;



